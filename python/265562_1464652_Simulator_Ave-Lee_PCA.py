

get_ipython().run_cell_magic('time', '', 'import sys\nfrom simulator import (\n    Simulator, string_to_micro, micro_to_time,\n    BUY, SELL, SHORT, EXCH_INET,\n    BOOK_DEPTH1_PRICE, ORDER_EVENTS,\n    )\nimport numpy as np\n%matplotlib inline\nimport matplotlib.pyplot as plt\nimport pandas as pd\nfrom sklearn.linear_model import LinearRegression\nfrom statsmodels.tsa.ar_model import AR\nfrom scipy import integrate \nfrom scipy import optimize\nimport random\n\n\nclass Ave_Lee(object):\n    def __init__(self, session, date, tickers, start_time, end_time, pnl, buy_dollars, sell_dollars, \n                 threshold, interval, training_size, trades, pca_weights, shares, ticker1):\n        self.session = session\n        self.date = date\n        self.ticker = ticker1\n        self.start_time = start_time\n        self.end_time = end_time\n        self.halt_trading = string_to_micro(\'5m\') # close position 5 minutes before trading ends\n        self.interval = string_to_micro(interval)\n        self.interval_pnl = string_to_micro(\'1s\')\n        self.state = \'NULL\'\n        self.pca_tickers = tickers\n        self.pca_weights = pca_weights\n        \n        # variables for BUY or SELL\n        self.side1 = 0\n        self.side2 = 0\n        \n        # variables for order size\n        self.order_size1 = 100\n        self.order_size2 = [0 for i in range(len(self.pca_tickers))]\n        self.buy_size = 10000 * 10**6\n        \n        # variables to keep track of total shares bought/sold and the corresponding amount of money\n        self.buy_dollars = buy_dollars\n        self.sell_dollars = sell_dollars\n        self.shares = shares\n        \n        # variables to keep track of how many positions we have opened and closed respectively\n        self.trades = trades\n        \n        # variables used for the fitOU, when to open/close a position and how far we look back\n        self.dt = 1\n        self.long_open = threshold[0]\n        self.long_close = threshold[1]\n        self.short_open = threshold[0]\n        self.short_close = threshold[2]\n        self.training_size = training_size\n        \n        # start timer/ call the start_callback function\n        self.session.add_timer(self.start_time, self.start_callback)\n        for tick in self.pca_tickers:\n            self.session.subscribe_ticker_all_feeds(tick)\n            \n        # list to store pnl every time we update it\n        self.pnl = pnl\n        \n        # dictionary to store time, midprices and the returns each timestep\n        self.results = {\'time\': []}\n        self.pca = {}\n        self.pca[\'Portfolio\'] = []\n        \n        self.results[self.ticker] = []\n        self.results[\'return {}\'.format(self.ticker)] = []\n        \n        for tick in self.pca_tickers:\n            self.pca[\'Midmarket {}\'.format(tick)] = []\n            self.pca[\'Return {}\'.format(tick)] = []\n    \n    \n    def start_callback(self, time):\n        for tick in self.pca_tickers:\n            self.session.subscribe_event(tick, ORDER_EVENTS, self.event_callback)\n            \n        self.session.add_timer(time, self.timer_callback_pnl)\n        self.session.add_timer(time, self.timer_callback_algo)\n        \n    \n    def event_callback(self, tick, event_params):\n        # call the execution manager whenever we have an execution\n        self.process_executions(event_params)\n        \n        \n    def timer_callback_pnl(self, time):   \n        # update pnl every second to see how it evolves over the day            \n        pnl = self.get_pnl()\n        self.pnl.append(pnl / 1000000.0)\n        \n        if time < self.end_time:\n            self.session.add_timer(time + self.interval_pnl, self.timer_callback_pnl)\n            \n    \n    def timer_callback_algo(self, time):\n        # append the midprices\n        self.results[self.ticker].append(self.get_midmarket(self.ticker) / 1000000.0)\n\n        for tick in self.pca_tickers:\n            self.pca[\'Midmarket {}\'.format(tick)].append(self.get_midmarket(tick) / 1000000.0)\n        \n        # start calculating returns after 1 second\n        if time > self.start_time + 10**6:\n            self.results[\'return {}\'.format(self.ticker)].append(np.float(returns(self.results[self.ticker][-2:])))\n            \n            temp_return = 0\n            for i in range(len(self.pca_tickers)):\n                tick = self.pca_tickers[i]\n                self.pca[\'Return {}\'.format(tick)].append(np.float(returns(self.pca[\'Midmarket {}\'.format(tick)][-2:])))\n                temp_return += self.pca[\'Return {}\'.format(tick)][-1] * self.pca_weights[i]\n                \n            self.pca[\'Portfolio\'].append(temp_return)\n            \n        self.results[\'time\'].append(micro_to_time(time))\n\n        # start collecting signals after training_size * 1 second\n        if time > self.start_time + self.halt_trading + self.training_size * 10**6:\n            # collect the last training_size of returns\n            returns1 = self.results[\'return {}\'.format(self.ticker)][-self.training_size:]\n            returns2 = self.pca[\'Portfolio\'][-self.training_size:]\n            \n            # regress the returns and fit the residuals, calculate the s-score\n            residuals, a,b = regress(returns1,returns2)\n            kappa, m, sigma, sigmaeq = fitOU(residuals, self.training_size)\n            s = sscore(m, sigmaeq)\n            # find current net position (=0: neutral, <0: we are short asset 1, >0: we are long asset 1)\n            pos = self.shares[self.ticker][\'B\'] - self.shares[self.ticker][\'S\']           \n            # feature to check if we have orders at the market before we open a position\n            orders = self.session.get_all_orders()\n            \n            # get the best bid and offer\n            bid1, ask1 = self.session.get_inside_market(self.ticker)\n            if not orders and b > 0 and kappa > 0 and sigma > 0 and time < self.end_time - self.halt_trading:\n                if pos == 0:\n                    if s < -self.long_open:\n                        self.side1 = BUY\n                        self.side2 = SELL\n                        price1 = ask1[\'price\']\n                        self.order_size1 = int(self.buy_size / price1)\n                        self.session.add_order(self.ticker, self.side1, self.order_size1, price1, exchange=EXCH_INET)\n                        for i in range(len(self.pca_tickers)):\n                            ticker = self.pca_tickers[i]\n                            bid2, ask2 = self.session.get_inside_market(ticker)\n                            price2 = bid2[\'price\']\n                            # make the portfolio self financing by making sure we sell for as much as we buy\n                            self.order_size2[i] = int(b * self.buy_size * self.pca_weights[i] / price2)\n                            self.session.add_order(ticker, self.side2, self.order_size2[i], price2, exchange=EXCH_INET)\n\n                        self.trades += 1 \n                    elif s > self.short_open:\n                        self.side1 = SELL\n                        self.side2 = BUY\n                        price1 = bid1[\'price\']\n                        self.order_size1 = int(self.buy_size / price1)\n                        self.session.add_order(self.ticker, self.side1, self.order_size1, price1, exchange=EXCH_INET)\n                        for i in range(len(self.pca_tickers)):\n                            ticker = self.pca_tickers[i]\n                            bid2, ask2 = self.session.get_inside_market(ticker)\n                            price2 = ask2[\'price\']\n                            # make the portfolio self financing by making sure we sell for as much as we buy\n                            self.order_size2[i] = int(b * self.buy_size * self.pca_weights[i] / price2)\n                            self.session.add_order(ticker, self.side2, self.order_size2[i], price2, exchange=EXCH_INET)\n\n                        self.trades += 1 \n                        \n                elif pos < 0 and s < self.short_close:\n                    self.side1 = BUY\n                    self.side2 = SELL\n                    price1 = ask1[\'price\']\n                    self.session.add_order(self.ticker, self.side1, self.order_size1, price1, exchange=EXCH_INET)\n                    for i in range(len(self.pca_tickers)):\n                        ticker = self.pca_tickers[i]\n                        bid2, ask2 = self.session.get_inside_market(ticker)\n                        price2 = bid2[\'price\']\n                        # make the portfolio self financing by making sure we sell for as much as we buy\n                        self.session.add_order(ticker, self.side2, self.order_size2[i], price2, exchange=EXCH_INET)\n \n                elif pos > 0 and s > -self.long_close:\n                    self.side1 = SELL\n                    self.side2 = BUY\n                    price1 = bid1[\'price\']\n                    self.session.add_order(self.ticker, self.side1, self.order_size1, price1, exchange=EXCH_INET)\n                    for i in range(len(self.pca_tickers)):\n                        ticker = self.pca_tickers[i]\n                        bid2, ask2 = self.session.get_inside_market(ticker)\n                        price2 = ask2[\'price\']\n                        # make the portfolio self financing by making sure we sell for as much as we buy\n                        self.session.add_order(ticker, self.side2, self.order_size2[i], price2, exchange=EXCH_INET)\n            \n        if time >= self.end_time - self.halt_trading and pos != 0:\n            if pos < 0:\n                self.side1 = BUY\n                self.side2 = SELL\n                price1 = ask1[\'price\']\n                self.session.add_order(self.ticker, self.side1, self.order_size1, price1, exchange=EXCH_INET)\n                for i in range(len(self.pca_tickers)):\n                    ticker = self.pca_tickers[i]\n                    bid2, ask2 = self.session.get_inside_market(ticker)\n                    price2 = bid2[\'price\']\n                    # make the portfolio self financing by making sure we sell for as much as we buy\n                    self.session.add_order(ticker, self.side2, self.order_size2[i], price2, exchange=EXCH_INET)\n                \n            elif pos > 0:\n                self.side1 = SELL\n                self.side2 = BUY\n                price1 = bid1[\'price\']\n                self.session.add_order(self.ticker, self.side1, self.order_size1, price1, exchange=EXCH_INET)\n                for i in range(len(self.pca_tickers)):\n                    ticker = self.pca_tickers[i]\n                    bid2, ask2 = self.session.get_inside_market(ticker)\n                    price2 = ask2[\'price\']\n                    # make the portfolio self financing by making sure we sell for as much as we buy\n                    self.session.add_order(ticker, self.side2, self.order_size2[i], price2, exchange=EXCH_INET)    \n    \n        # reset the timer unless we are done \n        if time < self.end_time:\n            self.session.add_timer(time + self.interval, self.timer_callback_algo)\n                \n            \n    def process_executions(self, evp):\n        # make sure that we only update if we have executed any orders\n        # when we want to add transaction costs we do it in this function\n        if \'executed_orders\' in evp:\n            time = self.session.current_time()\n            for ex in evp[\'executed_orders\']:\n                order = ex[\'order\']\n                side = order[\'side\']\n                ticker = order[\'ticker\']\n                        \n                self.shares[ticker][side] += ex[\'quantity_executed\']\n                if side == \'B\':\n                    self.buy_dollars += ex[\'quantity_executed\'] * self.get_midmarket(ticker)\n                else:\n                    self.sell_dollars += ex[\'quantity_executed\'] * self.get_midmarket(ticker)\n                pnl = self.get_pnl()\n               \n                \n    def get_midmarket(self, ticker):\n        bid, ask = self.session.get_inside_market(ticker)\n        return (bid[\'price\'] + ask[\'price\']) / 2.0\n    \n    \n    def get_pnl(self):\n        # mark to the midmarket\n        pnl = self.sell_dollars - self.buy_dollars\n        for ticker in self.pca_tickers:\n            mid = self.get_midmarket(ticker)\n            pnl += (self.shares[ticker][\'B\'] - self.shares[ticker][\'S\']) * mid\n        return pnl\n    \n    \n    def end(self):\n        plot_graph(self.pnl, self.ticker, \'PCA\')\n        return (self.pnl, self.buy_dollars, self.sell_dollars, self.trades, self.shares)\n\n\ndef regress(returns1,returns2):\n    x = np.asarray(returns1).reshape(-1,1)\n    y = np.asarray(returns2).reshape(-1,1)\n    model = LinearRegression()\n    model.fit(x,y)\n    a = model.intercept_[0]\n    b = model.coef_[0,0]\n    residuals = y-model.predict(x)\n    return residuals, a,b\n\n\ndef returns(midprices):\n    log_return = np.diff(np.log(midprices), axis=-1)\n    return log_return\n\n\ndef fitOU(residual, training_size):\n    dt = 1\n    ou = np.cumsum(residual)\n    model = AR(ou)\n    fittedmodel = model.fit(maxlag=1, disp=-1)  \n    a = fittedmodel.params[0]\n    b = fittedmodel.params[1]\n    var =  fittedmodel.sigma2\n    if b > 0.0 and b < np.exp(-2.0/training_size):\n        kappa = -np.log(b) / dt    \n        m = a / (1.0 - np.exp(-kappa * dt))\n        sigma = np.sqrt(var * 2.0 * kappa / (1.0 - np.exp(-2.0 * kappa * dt)))\n        sigmaeq = np.sqrt(var / (1.0 - np.exp(-2.0 * kappa * dt)));\n        return kappa, m, sigma, sigmaeq\n    else:\n        return -1.0,0,0,0\n\n\ndef sscore(m, sigmaeq):\n    if sigmaeq != 0:\n        return -m/sigmaeq\n    elif m>0:\n        return 10000000\n    else:\n        return -10000000\n\n\ndef plot_graph(pnl, ticker1, ticker2):\n    pnl_array = np.asarray(pnl)\n    plt.plot(pnl_array)\n    plt.title(\'PnL for {} vs {}\'.format(ticker1, ticker2))\n    plt.show()\n    return None\n    \n\n# generalize the process of simulating the algorithm\nstart_time = string_to_micro("9:30")\nend_time = string_to_micro("16:00")\ndates = [\'20170418\', \'20170419\', \'20170420\', \'20170421\', \'20170424\']\n        #[\'20170410\', \'20170411\', \'20170412\', \'20170413\', \'20170417\'] \n         #\'20170418\', \'20170419\', \'20170420\', \'20170421\', \'20170424\']\n\npca_tickers = [\'AAPL\', \'MSFT\', \'GOOGL\', \'FB\', \'INTC\', \'CSCO\', \'NVDA\', \n               \'ADBE\', \'TXN\', \'AVGO\', \'QCOM\', \'MU\', \'BIDU\']\ntickers = [\'AAPL\', \'INTC\', \'NVDA\', \'TXN\', \'QCOM\', \'MU\']\n\npca_weights = [0.20616074, 0.29121571, 0.28953237, 0.25233613, 0.31817724,\n                 0.28766794, 0.24683757, 0.30186135, 0.31492926, 0.29388122,\n                 0.27183746, 0.27004335, 0.23829469]\npca_weights = pca_weights / np.sum(pca_weights)\n\nthreshold = [1.4790482779731475, 0.44463939623560345, 0.7982635907763361]\ninterval = \'9s\'\ntraining_size = 279\nprint(threshold, interval, training_size)\navg_dollar_trade = 0\n\nfor ticker1 in tickers:   \n    pnl = []         \n    buy_dollars = 0\n    sell_dollars = 0\n    trades = 0\n    shares = {}\n    for tick in pca_tickers:\n        shares[tick] = {\'B\': 0, \'S\': 0}\n        \n    for date in dates:\n        sim = Simulator(Ave_Lee)\n        (pnl, buy_dollars, sell_dollars, trades, shares) = sim.run(date, pca_tickers, use_om=True, \n                start_time=start_time, end_time=end_time, pnl=pnl, buy_dollars=buy_dollars, \n                sell_dollars=sell_dollars, threshold=threshold, interval=interval, training_size=training_size, \n                trades=trades, pca_weights=pca_weights, shares=shares, ticker1=ticker1)\n        \n    plot_graph(pnl, ticker1, \'PCA\')\n    print(\'Number of trades: \' + str(trades))\n    if trades > 0:   \n        dollar_trade = pnl[-1] / (10000 * trades)  \n        print(\'Dollar per trade: \' + str(dollar_trade))\n        \n    avg_dollar_trade += dollar_trade / len(ticker1)\nprint(avg_dollar_trade)\n             ')

print('Best dollar per trade: ' + str(best_dollar_trade))
print(best_threshold)
print(best_interval)
print(best_size)

get_ipython().run_cell_magic('time', '', '##The parameters are the same as in the other file, BUT threshold is removed, and instead we have to choose constans rho>0 (urgency parameter) and c\n## and c>0 (a measure of the transaction costs). I have incorportared these two parameters to the class constructor and removed thresholds\n## rho should be close to 0 (I have tried 0.01 and 0.001) and c as well (I have tried 0.01)\n\n##The only differences with the other file are the block with all the new functions to compute the thresholds, and then in the execution part\n#that instead of comparing s with fixed thresholds, we compare the last residual with a threshold that deppends on the OU parameters\n\n\nimport sys\nfrom simulator import (\n    Simulator, string_to_micro, micro_to_time,\n    BUY, SELL, SHORT, EXCH_INET,\n    BOOK_DEPTH1_PRICE, ORDER_EVENTS,\n    )\nimport numpy as np\n%matplotlib inline\nimport matplotlib.pyplot as plt\nimport pandas as pd\nfrom sklearn.linear_model import LinearRegression\nfrom statsmodels.tsa.ar_model import AR\nfrom scipy import integrate \nfrom scipy import optimize\n\nclass Ave_Lee(object):\n    def __init__(self, session, date, tickers, start_time, end_time, pnl, buy_dollars, sell_dollars,\n                 interval, training_size, trades, pca_weights, shares, ticker1, rho, c):\n        self.session = session\n        self.date = date\n        self.ticker = ticker1\n        self.start_time = start_time\n        self.end_time = end_time\n        self.halt_trading = string_to_micro(\'5m\') # close position 5 minutes before trading ends\n        self.interval = string_to_micro(interval)\n        self.interval_pnl = string_to_micro(\'1s\')\n        self.state = \'NULL\'\n        self.pca_tickers = tickers\n        self.pca_weights = pca_weights\n        \n        # variables for BUY or SELL\n        self.side1 = 0\n        self.side2 = 0\n        \n        # variables for order size\n        self.order_size1 = 100\n        self.order_size2 = [0 for i in range(len(self.pca_tickers))]\n        self.buy_size = 10000 * 10**6\n        \n        # variables to keep track of total shares bought/sold and the corresponding amount of money\n        self.buy_dollars = buy_dollars\n        self.sell_dollars = sell_dollars\n        self.shares = shares\n        \n        # variables to keep track of how many positions we have opened and closed respectively\n        self.trades = trades\n        \n        # variables used for the fitOU, when to open/close a position and how far we look back\n        self.dt = 1\n        self.rho = rho\n        self.c = c\n        self.training_size = training_size\n        \n        # start timer/ call the start_callback function\n        self.session.add_timer(self.start_time, self.start_callback)\n        for tick in self.pca_tickers:\n            self.session.subscribe_ticker_all_feeds(tick)\n            \n        # list to store pnl every time we update it\n        self.pnl = pnl\n        \n        # dictionary to store time, midprices and the returns each timestep\n        self.results = {\'time\': []}\n        self.pca = {}\n        self.pca[\'Portfolio\'] = []\n        \n        self.results[self.ticker] = []\n        self.results[\'return {}\'.format(self.ticker)] = []\n        \n        for tick in self.pca_tickers:\n            self.pca[\'Midmarket {}\'.format(tick)] = []\n            self.pca[\'Return {}\'.format(tick)] = []\n    \n    \n    def start_callback(self, time):\n        for tick in self.pca_tickers:\n            self.session.subscribe_event(tick, ORDER_EVENTS, self.event_callback)\n            \n        self.session.add_timer(time, self.timer_callback_pnl)\n        self.session.add_timer(time, self.timer_callback_algo)\n        \n    \n    def event_callback(self, tick, event_params):\n        # call the execution manager whenever we have an execution\n        self.process_executions(event_params)\n        \n        \n    def timer_callback_pnl(self, time):   \n        # update pnl every second to see how it evolves over the day            \n        pnl = self.get_pnl()\n        self.pnl.append(pnl / 1000000.0)\n        \n        if time < self.end_time:\n            self.session.add_timer(time + self.interval_pnl, self.timer_callback_pnl)\n            \n    \n    def timer_callback_algo(self, time):\n        # append the midprices\n        self.results[self.ticker].append(self.get_midmarket(self.ticker) / 1000000.0)\n\n        for tick in self.pca_tickers:\n            self.pca[\'Midmarket {}\'.format(tick)].append(self.get_midmarket(tick) / 1000000.0)\n        \n        # start calculating returns after 1 second\n        if time > self.start_time + 10**6:\n            self.results[\'return {}\'.format(self.ticker)].append(np.float(returns(self.results[self.ticker][-2:])))\n            \n            temp_return = 0\n            for i in range(len(self.pca_tickers)):\n                tick = self.pca_tickers[i]\n                self.pca[\'Return {}\'.format(tick)].append(np.float(returns(self.pca[\'Midmarket {}\'.format(tick)][-2:])))\n                temp_return += self.pca[\'Return {}\'.format(tick)][-1] * self.pca_weights[i]\n                \n            self.pca[\'Portfolio\'].append(temp_return)\n            \n        self.results[\'time\'].append(micro_to_time(time))\n\n        # start collecting signals after training_size * 1 second\n        if time > self.start_time + self.halt_trading + self.training_size * 10**6:\n            # collect the last training_size of returns\n            returns1 = self.results[\'return {}\'.format(self.ticker)][-self.training_size:]\n            returns2 = self.pca[\'Portfolio\'][-self.training_size:]\n            \n            # regress the returns and fit the residuals, calculate the s-score\n            residuals, a,b = regress(returns1,returns2)\n            kappa, m, sigma, sigmaeq = fitOU(residuals, self.training_size)\n            \n            # find current net position (=0: neutral, <0: we are short asset 1, >0: we are long asset 1)\n            pos = self.shares[self.ticker][\'B\'] - self.shares[self.ticker][\'S\']           \n            # feature to check if we have orders at the market before we open a position\n            orders = self.session.get_all_orders()\n            \n            residual = 3 * residuals[-1]\n            \n            # get the best bid and offer\n            bid1, ask1 = self.session.get_inside_market(self.ticker)\n            if not orders and b > 0 and kappa > 0 and sigma > 0 and time < self.end_time - self.halt_trading:\n                if pos == 0:\n                    if residual < long_open(self.rho,kappa,m,sigma, self.c):\n                        self.side1 = BUY\n                        self.side2 = SELL\n                        price1 = ask1[\'price\']\n                        self.order_size1 = int(self.buy_size / price1)\n                        self.session.add_order(self.ticker, self.side1, self.order_size1, price1, exchange=EXCH_INET)\n                        for i in range(len(self.pca_tickers)):\n                            ticker = self.pca_tickers[i]\n                            bid2, ask2 = self.session.get_inside_market(ticker)\n                            price2 = bid2[\'price\']\n                            # make the portfolio self financing by making sure we sell for as much as we buy\n                            self.order_size2[i] = int(b * self.buy_size * self.pca_weights[i] / price2)\n                            self.session.add_order(ticker, self.side2, self.order_size2[i], price2, exchange=EXCH_INET)\n\n                        self.trades += 1 \n                    elif residual > short_open(self.rho,kappa,m,sigma, self.c):\n                        self.side1 = SELL\n                        self.side2 = BUY\n                        price1 = bid1[\'price\']\n                        self.order_size1 = int(self.buy_size / price1)\n                        self.session.add_order(self.ticker, self.side1, self.order_size1, price1, exchange=EXCH_INET)\n                        for i in range(len(self.pca_tickers)):\n                            ticker = self.pca_tickers[i]\n                            bid2, ask2 = self.session.get_inside_market(ticker)\n                            price2 = ask2[\'price\']\n                            # make the portfolio self financing by making sure we sell for as much as we buy\n                            self.order_size2[i] = int(b * self.buy_size * self.pca_weights[i] / price2)\n                            self.session.add_order(ticker, self.side2, self.order_size2[i], price2, exchange=EXCH_INET)\n\n                        self.trades += 1 \n                        \n                elif pos < 0 and residual < short_close(self.rho,kappa,m,sigma, self.c):\n                    self.side1 = BUY\n                    self.side2 = SELL\n                    price1 = ask1[\'price\']\n                    self.session.add_order(self.ticker, self.side1, self.order_size1, price1, exchange=EXCH_INET)\n                    for i in range(len(self.pca_tickers)):\n                        ticker = self.pca_tickers[i]\n                        bid2, ask2 = self.session.get_inside_market(ticker)\n                        price2 = bid2[\'price\']\n                        # make the portfolio self financing by making sure we sell for as much as we buy\n                        self.session.add_order(ticker, self.side2, self.order_size2[i], price2, exchange=EXCH_INET)\n \n                elif pos > 0 and residual > long_close(self.rho, kappa, m, sigma, self.c):\n                    self.side1 = SELL\n                    self.side2 = BUY\n                    price1 = bid1[\'price\']\n                    self.session.add_order(self.ticker, self.side1, self.order_size1, price1, exchange=EXCH_INET)\n                    for i in range(len(self.pca_tickers)):\n                        ticker = self.pca_tickers[i]\n                        bid2, ask2 = self.session.get_inside_market(ticker)\n                        price2 = ask2[\'price\']\n                        # make the portfolio self financing by making sure we sell for as much as we buy\n                        self.session.add_order(ticker, self.side2, self.order_size2[i], price2, exchange=EXCH_INET)\n            \n        if time >= self.end_time - self.halt_trading and pos != 0:\n            if pos < 0:\n                self.side1 = BUY\n                self.side2 = SELL\n                price1 = ask1[\'price\']\n                self.session.add_order(self.ticker, self.side1, self.order_size1, price1, exchange=EXCH_INET)\n                for i in range(len(self.pca_tickers)):\n                    ticker = self.pca_tickers[i]\n                    bid2, ask2 = self.session.get_inside_market(ticker)\n                    price2 = bid2[\'price\']\n                    # make the portfolio self financing by making sure we sell for as much as we buy\n                    self.session.add_order(ticker, self.side2, self.order_size2[i], price2, exchange=EXCH_INET)\n                \n            elif pos > 0:\n                self.side1 = SELL\n                self.side2 = BUY\n                price1 = bid1[\'price\']\n                self.session.add_order(self.ticker, self.side1, self.order_size1, price1, exchange=EXCH_INET)\n                for i in range(len(self.pca_tickers)):\n                    ticker = self.pca_tickers[i]\n                    bid2, ask2 = self.session.get_inside_market(ticker)\n                    price2 = ask2[\'price\']\n                    # make the portfolio self financing by making sure we sell for as much as we buy\n                    self.session.add_order(ticker, self.side2, self.order_size2[i], price2, exchange=EXCH_INET)    \n    \n        # reset the timer unless we are done \n        if time < self.end_time:\n            self.session.add_timer(time + self.interval, self.timer_callback_algo)\n                \n            \n    def process_executions(self, evp):\n        # make sure that we only update if we have executed any orders\n        # when we want to add transaction costs we do it in this function\n        if \'executed_orders\' in evp:\n            time = self.session.current_time()\n            for ex in evp[\'executed_orders\']:\n                order = ex[\'order\']\n                side = order[\'side\']\n                ticker = order[\'ticker\']\n                        \n                self.shares[ticker][side] += ex[\'quantity_executed\']\n                if side == \'B\':\n                    self.buy_dollars += ex[\'quantity_executed\'] * self.get_midmarket(ticker)\n                else:\n                    self.sell_dollars += ex[\'quantity_executed\'] * self.get_midmarket(ticker)\n                pnl = self.get_pnl()\n               \n                \n    def get_midmarket(self, ticker):\n        bid, ask = self.session.get_inside_market(ticker)\n        return (bid[\'price\'] + ask[\'price\']) / 2.0\n    \n    \n    def get_pnl(self):\n        # mark to the midmarket\n        pnl = self.sell_dollars - self.buy_dollars\n        for ticker in self.pca_tickers:\n            mid = self.get_midmarket(ticker)\n            pnl += (self.shares[ticker][\'B\'] - self.shares[ticker][\'S\']) * mid\n        return pnl\n    \n    \n    def end(self):\n        return (self.pnl, self.buy_dollars, self.sell_dollars, self.trades, self.shares)\n\n\ndef regress(returns1,returns2):\n    x = np.asarray(returns1).reshape(-1,1)\n    y = np.asarray(returns2).reshape(-1,1)\n    model = LinearRegression()\n    model.fit(x,y)\n    a = model.intercept_[0]\n    b = model.coef_[0,0]\n    residuals = y-model.predict(x)\n    return residuals, a,b\n\n\ndef returns(midprices):\n    log_return = np.diff(np.log(midprices), axis=-1)\n    return log_return\n\n\ndef fitOU(residual, training_size):\n    dt = 1\n    ou = np.cumsum(residual)\n    model = AR(ou)\n    fittedmodel = model.fit(maxlag=1, disp=-1)  \n    a = fittedmodel.params[0]\n    b = fittedmodel.params[1]\n    var =  fittedmodel.sigma2\n    if b > 0.0 and b < np.exp(-2.0/training_size):\n        kappa = -np.log(b) / dt    \n        m = a / (1.0 - np.exp(-kappa * dt))\n        sigma = np.sqrt(var * 2.0 * kappa / (1.0 - np.exp(-2.0 * kappa * dt)))\n        sigmaeq = np.sqrt(var / (1.0 - np.exp(-2.0 * kappa * dt)));\n        return kappa, m, sigma, sigmaeq\n    else:\n        return -1.0,0,0,0\n\n\ndef plot_graph(pnl, ticker1, ticker2):\n    pnl_array = np.asarray(pnl)\n    plt.plot(pnl_array)\n    plt.title(\'PnL for {} vs {}\'.format(ticker1, ticker2))\n    plt.show()\n    return None\n\n\n#### Functions to compute thresholds\ndef fplus(u,rho,epsilon,kappa, theta, sigma):\n    #return u**(rho/kappa-1)*np.exp(-np.sqrt(2*kappa/sigma**2)*(theta-epsilon)*u-u**2/2)\n    return sigma**(rho/kappa)*u**(rho/kappa-1)*np.exp(-np.sqrt(2*kappa)*(theta-epsilon)*u-(u*sigma)**2/2)\n\n\ndef fplus_der(u,rho,epsilon,kappa, theta, sigma):\n    #return np.sqrt(2*kappa/sigma**2)*u**(rho/kappa)*np.exp(-np.sqrt(2*kappa/sigma**2)*(theta-epsilon)*u-u**2/2)\n    return sigma**(rho/kappa)*np.sqrt(2*kappa)*u**(rho/kappa)*np.exp(-np.sqrt(2*kappa)*(theta-epsilon)*u-(u*sigma)**2/2)\n\n\ndef fminus(u,rho,epsilon,kappa, theta, sigma):\n    #return u**(rho/kappa-1)*np.exp(np.sqrt(2*kappa/sigma**2)*(theta-epsilon)*u-u**2/2)\n    return sigma**(rho/kappa)*u**(rho/kappa-1)*np.exp(np.sqrt(2*kappa)*(theta-epsilon)*u-(u*sigma)**2/2)\n\n\ndef fminus_der(u,rho,epsilon,kappa, theta, sigma):\n    #return -np.sqrt(2*kappa/sigma**2)*u**(rho/kappa)*np.exp(np.sqrt(2*kappa/sigma**2)*(theta-epsilon)*u-u**2/2)\n    return -sigma**(rho/kappa)*np.sqrt(2*kappa)*u**(rho/kappa)*np.exp(-np.sqrt(2*kappa)*(theta-epsilon)*u-(u*sigma)**2/2)\n\n\ndef Fplus(epsilon,rho, kappa, theta, sigma):\n    integral,error = integrate.quad(fplus,0, np.inf, args = (rho,epsilon,kappa,theta,sigma,))\n    return integral\n\n\ndef Fminus(epsilon,rho, kappa, theta, sigma):\n    integral,error = integrate.quad(fminus,0, np.inf, args = (rho,epsilon,kappa,theta,sigma,))\n    return integral\n\n\ndef Fplus_der(epsilon,rho, kappa, theta, sigma):\n    integral,error = integrate.quad(fplus_der,0, np.inf, args = (rho,epsilon,kappa,theta,sigma,))\n    return integral\n\n\ndef Fminus_der(epsilon,rho, kappa, theta, sigma):\n    integral,error = integrate.quad(fminus_der,0, np.inf, args = (rho,epsilon,kappa,theta,sigma,))\n    return integral\n\n\ndef long_close_function(epsilon,rho, kappa, theta, sigma,c):\n    return (epsilon[0] - c)*Fplus_der(epsilon[0],rho, kappa, theta, sigma)-Fplus(epsilon[0],rho, kappa, theta, sigma)\n\n\ndef long_close(rho, kappa, theta, sigma, c): #epsilon^*+\n    result = optimize.root(long_close_function,[1], args=(rho, kappa, theta, sigma, c,), method = \'lm\')\n    if result.success:\n        return result.x[0]\n    else:\n        return (kappa*theta+c*rho)/(rho+kappa)\n\n    \ndef short_close_function(epsilon,rho, kappa, theta, sigma,c):\n    return (epsilon[0] + c)*Fminus_der(epsilon[0],rho, kappa, theta, sigma)-Fminus(epsilon[0],rho, kappa, theta, sigma)\n\n\ndef short_close(rho, kappa, theta, sigma, c): #epsilon^*-\n    result = optimize.root(short_close_function,[-1], args=(rho, kappa, theta, sigma, c,), method = \'lm\')\n    if result.success:\n        return result.x[0]\n    else:\n        return (kappa*theta-c*rho)/(rho+kappa)\n\n    \ndef Hplus(epsilon,kappa,theta, sigma,rho,c):\n    epsilonplus = long_close(rho, kappa, theta, sigma,c)\n    if epsilon >= epsilonplus:\n        return epsilon - c\n    else:\n        return (epsilonplus - c)*Fplus(epsilon,rho, kappa, theta, sigma)/Fplus(epsilonplus,rho, kappa, theta, sigma)\n    \n    \ndef Hplus_der(epsilon,kappa,theta, sigma,rho,c):\n    epsilonplus = long_close(rho, kappa, theta, sigma,c)\n    if epsilon >= epsilonplus:\n        return 1\n    else:\n        return (epsilonplus - c)*Fplus_der(epsilon,rho, kappa, theta, sigma)/Fplus(epsilonplus,rho, kappa, theta, sigma)\n\n    \ndef Hminus(epsilon,kappa,theta, sigma,rho, c):\n    epsilonminus = short_close(rho, kappa, theta, sigma,c)\n    if epsilon <= epsilonminus:\n        return -epsilon - c\n    else:\n        return -(epsilonminus + c)*Fminus(epsilon,rho, kappa, theta, sigma)/Fminus(epsilonminus,rho, kappa, theta, sigma)\n    \n    \ndef Hminus_der(epsilon,kappa,theta, sigma,rho, c):\n    epsilonminus = short_close(rho, kappa, theta, sigma,c)\n    if epsilon <= epsilonminus:\n        return -1\n    else:\n        return -(epsilonminus + c)*Fminus_der(epsilon,rho, kappa, theta, sigma)/Fminus(epsilonminus,rho, kappa, theta, sigma)\n\n    \ndef long_short_open_function(epsilon,rho,kappa,theta,sigma, c):\n    minusepsilon = epsilon[0]\n    plusepsilon = epsilon[1]\n    \n    numA = Fminus(minusepsilon,rho, kappa, theta, sigma)*(Hplus(plusepsilon,kappa,theta,sigma,rho,c)-plusepsilon-c)-Fminus(plusepsilon,rho, kappa, theta, sigma)*(Hminus(minusepsilon,kappa,theta,sigma,rho,c)+minusepsilon-c)\n    denA = Fplus(plusepsilon,rho, kappa, theta, sigma)*Fminus(minusepsilon,rho, kappa, theta, sigma)-Fplus(minusepsilon,rho, kappa, theta, sigma)*Fminus(plusepsilon,rho, kappa, theta, sigma)\n    A = numA/denA\n\n    numB = Fplus(minusepsilon,rho, kappa, theta, sigma)*(Hplus(plusepsilon,kappa,theta,sigma,rho,c)-plusepsilon-c)-Fplus(plusepsilon,rho, kappa, theta, sigma)*(Hminus(minusepsilon,kappa,theta,sigma,rho,c)+minusepsilon-c)\n    denB = Fminus(plusepsilon,rho, kappa, theta, sigma)*Fplus(minusepsilon,rho, kappa, theta, sigma)-Fminus(minusepsilon,rho, kappa, theta, sigma)*Fplus(plusepsilon,rho, kappa, theta, sigma)\n    B = numB/denB\n    \n    y_0 = A*Fplus_der(plusepsilon,rho, kappa, theta, sigma)+B*Fminus_der(plusepsilon,rho, kappa, theta, sigma)+1-Hplus_der(plusepsilon,kappa,theta, sigma,rho, c)\n    y_1 = A*Fplus_der(minusepsilon,rho, kappa, theta, sigma)+B*Fminus_der(minusepsilon,rho, kappa, theta, sigma)-1-Hminus_der(minusepsilon,kappa,theta, sigma,rho, c)\n    \n    return [y_0,y_1]\n\n\ndef long_short_open(rho,kappa,theta,sigma, c):\n    return optimize.root(long_short_open_function,[-0.18,1.5 ], args=(rho, kappa, theta, sigma, c,), method = \'hybr\').x\n\n\ndef long_open(rho,kappa,theta,sigma, c):\n    return short_close(rho,kappa,theta,sigma, c)\n\n\ndef short_open(rho,kappa,theta,sigma, c):\n    return long_close(rho,kappa,theta,sigma, c)\n\n\n\n# generalize the process of simulating the algorithm\nstart_time = string_to_micro("9:30")\nend_time = string_to_micro("16:00")\ndates = [\'20170508\', \'20170509\', \'20170510\', \'20170511\', \'20170512\']\n\n\npca_tickers = [\'AAPL\', \'MSFT\', \'GOOGL\', \'FB\', \'INTC\', \'CSCO\', \'NVDA\', \n               \'ADBE\', \'TXN\', \'AVGO\', \'QCOM\', \'MU\', \'BIDU\']\n\ntickers = [\'AAPL\', \'INTC\', \'NVDA\', \'TXN\', \'QCOM\', \'MU\']\n\npca_weights = [0.20616074, 0.29121571, 0.28953237, 0.25233613, 0.31817724,\n                 0.28766794, 0.24683757, 0.30186135, 0.31492926, 0.29388122,\n                 0.27183746, 0.27004335, 0.23829469]\npca_weights = pca_weights / np.sum(pca_weights)\n\nrho = 1.9\nc = 0\ninterval = \'9s\'\ntraining_size = 279\nprint(rho, interval, training_size)\navg_dollar_trade = 0\npnl_aggregate = {}\n\nfor ticker1 in tickers:   \n    pnl = []         \n    buy_dollars = 0\n    sell_dollars = 0\n    trades = 0\n    shares = {}\n    for tick in pca_tickers:\n        shares[tick] = {\'B\': 0, \'S\': 0}\n        \n    for date in dates:\n        sim = Simulator(Ave_Lee)\n        (pnl, buy_dollars, sell_dollars, trades, shares) = sim.run(date, pca_tickers, use_om=True, \n                start_time=start_time, end_time=end_time, pnl=pnl, buy_dollars=buy_dollars, \n                sell_dollars=sell_dollars, interval=interval, training_size=training_size, \n                trades=trades, pca_weights=pca_weights, shares=shares, ticker1=ticker1, rho=rho, c=c)\n        \n    plot_graph(pnl, ticker1, \'PCA\')\n    print(\'Number of trades: \' + str(trades))\n    if trades > 0:   \n        dollar_trade = pnl[-1] / (10000 * trades)  \n        print(\'Dollar per trade: \' + str(dollar_trade))        \n    pnl_aggregate[ticker1] = pnl\n    avg_dollar_trade += dollar_trade / len(tickers)\nprint(avg_dollar_trade)')

plt.plot(pnl_aggregate['AAPL'])
plt.show()

# all stocks pnl's together
pnl_simul = np.zeros((len(pnl_aggregate['AAPL']),1))
for ticker in pnl_aggregate.keys():
    pnl_simul += np.asarray(pnl_aggregate[ticker]).reshape(-1,1)

plt.plot(pnl_simul)
plt.title('Aggregated PnL')
plt.show()

pnl_diff = np.diff(pnl_simul[585:], axis=0)

plt.hist(pnl_diff, bins=200)
plt.axis([-5, 5, 0, 10000])
plt.title('Histogram of PnL changes')
plt.show()

np.mean(pnl_diff)





